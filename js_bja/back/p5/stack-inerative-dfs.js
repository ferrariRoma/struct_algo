/**
DFS를 iteractive하게 구현하는 법을 살펴보자.
iteractive? 사전적으로는 반복적이라는 뜻인데,
각 언어에서 반복문을 통해 순차적으로 접근이 가능한 자료형을 말한다.

JS에서는 Array,Map,Set등이 기본적으로 iteractive하다.
쉽게 말해 for-in/for-of와 같은 반복문으로 돌릴 수 있냐로 판가름할 수 있을 것이다.

<Iteractive DFS>
iterative DFS는 DFS를 주로 Stack을 이용해서 구현하는 것을 말한다.
보통 DFS를 접할 때 재귀적인 방법으로 구현하는 것으로 많이들 배운다.
DFS알고리즘을 구현할 때 크게 두 가지 방법으로 접근할 수 있다.

1. 재귀호출 방식
2. Stack을 이용하여 구현

보통 1번 방식으로 많이 구현하는 이유는 재귀호출 방식이 더 이해하기 또는 구현하기
편리한 경우가 많기 때문이다.
의문이 들 수 있겠지만 재귀로 풀이하는게 익숙하다면 확실히 더 편리하고,
그렇지 않더라도 DFS에서 만큼은 재귀가 더 강점을 지니는 것 같다.

그렇다면 왜 재귀 말고 stack을 이용해서 구현해야 하는지에 대한 의문이 들 수 있다.
자바스크립트로는 대부분 DFS알고리즘에서 주어지는 데이터를 가지고 재귀 호출 방식으로 구현한다면
호출 스택이 여지없이 터져버린다.

<자바스크립트 호출 스택>
브라우저 환경마다 호출 스택의 Maximum size가 다르고, 
또한 호출되는 함수내부가 어떻게 구현되어 있는지에 따라서도 
Maximum Size가 다르지만 보통 안정적으로 만 번 이상 재귀 호출 된다면 
우리의 연약한 자바스크립트 호출 스택은 위태하다고 보면 된다.

실제로 스택 오버플로우 사이트에 올라온 질문을 참고해보면 
아래와 같이 간단한 함수를 하나 만들고 이를 무한정 재귀호출 했을 때 
각 브라우저별로 나타나는 호출 스택의 Maximum Size는 다음과 같았다.

Internet Explorer
    IE6: 1130
    IE7: 2553
    IE8: 1475
    IE9: 20678
    IE10: 20677
Mozilla Firefox
    3.6: 3000
    4.0: 9015
    5.0: 9015
    6.0: 9015
    7.0: 65533

Google Chrome
    14: 26177
    15: 26168
    16: 26166
    25: 25090
    47: 20878
    51: 41753
Safari
    4: 52426
    5: 65534
    9: 63444
Opera
    10.10: 9999
    10.62: 32631
    11: 32631
    12: 32631
Edge
    87: 13970


하지만 대부분의 코딩 테스트에서는 데이터의 범위를 
몇 만 수준으로 찔끔 주는 경우는 없다. 때문에 js가 터져나가는 것이다.
즉 재귀호출로 풀 수 있을 데이터의 양이거나 또는 가지치기가 잘 되어
maximum size 이내로 재귀 호출이 되는 경우엔 DFS재귀 방식으로도 통과가 가능하다.
하지만 그 외 경우엔 재귀호출 방식으로는 통과하기 매우 어렵다.

<Recursive vs Iterative>
재귀가 편하다, 간단하다고 했는데 왜 그렇게 말하는지 몸소 느껴보자.
 */

// Recursive DFS
/* let sum = 0;
const dfs = (start, prev) => {
  for (const next of tree[start]) {
    if (next === prev) continue;
    dfs(next, start);
  }
  sum += Math.abs(a[start]);
  a[prev] += a[start];
};
dfs(0, -1); */

// Iterative DFS
/* const stack = [[0, -1]];
const visit = new Array(a.length).fill(false);

let answer = 0;
while (stack.length) {
  const [start, parent] = stack.pop();
  if (visit[start]) {
    a[parent] += a[start];
    answer += Math.abs(a[start]);
    continue;
  }

  stack.push([start, parent]);
  visit[start] = true;
  for (const next of tree[start]) {
    if (!visit[next]) {
      stack.push([next, start]);
    }
  }
} */

/**
일단 코드 양만 봐도 후자가 더 길다. 물론 단순히 코드 양이 많다고 해서 
불편하다는 것은 아니다.
DFS방식에서 간단하게 구현할 수 있는 부분을 iterative에서는 
한 번 더 생각해주어야 한다.

특히 까다로운 이유 중에 하나는 리프노드에서 어떤 연산을 시작하여 
해당 결과값을 자기 부모노드로 쭈욱 전달해 최종적으로 
루트노드로 이 값을 가져오는 경우이다.
대부분의 DFS알고리즘을 요구하는 문제에서 필요로 하는 로직이다.

Recursive DFS의 경우엔 해당 연산을 모든 탐색이 끝나는 지점에서 수행이 가능하다.
즉, dfs()를 자가호출 하는 반복문이 끝나는 외부의 영역이다.
재귀 호출의 흐름에 익숙하다면 해당 영역이 왜 더 이상 깊이 내려가 탐색할 노드가 없을 때
수행되는 영역인지 알 수 있을 것이다. 말 그대로 해당 영역은 나와 연결된 노드 중에
더 이상 탐색할 공간이 없을 때 (for문이 실행되지 않을 때) 수행되는 공간이기 때문이다.

<Iterative DFS 방문 순서>
여기서 BFS탐색과 해당 과정이 어느정도 닮아 있는데,
가장 중요한 차이점은 BFS탐색의 경우는 큐 자료구조를 사용해 FIFO원칙을 이용하고,
DFS를 스택으로 구현할 때는 스택을 사용해 LIFO원칙을 이용한다는 것이다.
왜냐하면 우리는 깊이를 위주로 탐색을 해야하기 때문에 가장 마지막에 담긴 원소를 
기준 삼아 계속 depth를 깊게 내려갈 것이기 때문이다.

<부모노드를 찾아서>
여러가지 방법이 있겠지만, 가장 직관적인 방법을 택하자.
부모 노드의 정보를 매핑해주는 것이다. 매핑의 형태는 객체를 써도 되고
ES7문법의 Map자료형을 써도 되고 상관없다. 어차피 부모 노드는 단 한 개 이므로
그냥 배열로 매핑하겠다.
*/
